# 📌 트랜잭션 격리 수준(Isolation Level)
- 여러 트랜잭션이 동시에 실행될 때 각 트랜잭션이 다른 트랜잭션의 작업에 얼마나 영향을 받지 않을지를 결정하는 설정임.**
- **격리 수준이 낮을수록 동시성이 높아지고 성능이 좋아지지만, 데이터 일관성이 떨어질 수 있음. 반대로 격리 수준이 높을수록 데이터 일관성은 높아지지만 성능이 저하될 수 있음.**

<br><br>

---

## ⚠️ 트랜잭션 이상현상
| 문제 유형 | 설명 | 예시 |
|----------|------|------|
| **Dirty Read (더티 리드)** | Commit되지 않은 데이터를 다른 트랜잭션이 읽을 수 있음 | A 트랜잭션이 데이터를 수정했지만 Commit 전에 B 트랜잭션이 읽음. 이후 A가 Rollback하면, B는 잘못된 데이터를 읽은 셈이 됨 |
| **Non-Repeatable Read (반복 가능하지 않은 읽기)** | 동일한 `SELECT` 문을 실행했을 때, 다른 값이 조회될 수 있음 | 첫 번째 조회 후, 다른 트랜잭션이 데이터를 수정 및 Commit하면 두 번째 조회에서 값이 달라짐 |
| **Phantom Read (팬텀 리드)** | 동일한 `SELECT` 문을 실행했을 때, 새로운 데이터가 추가되거나 삭제될 수 있음 | 첫 번째 조회 후, 다른 트랜잭션이 데이터를 Insert/Delete 후 Commit하면 두 번째 조회에서 레코드 수가 달라짐 |

### 1️⃣ Dirty Read
- 데이터 x = 10 , y = 50

| 트랜잭션A                | 트랜잭션B           |
|----------------------|-----------------|
| 로직 : x에 y 더함         | 로직 : y=70 으로 변경 |
| 🚀 시작                |                 |
| 👀 x=10 읽음           | 🚀 시작           |
|                      | ✍️ y=70 으로 변경   |
| 👀 y=70 읽음           |                 |
| ✍️ x 에 y를 더해 x=80으로 변경 |                 |
| ✅ 커밋                 |                 |
|                      | 🚨 롤백 y = 50 으로 |
| 💥 B의 롤백으로 x값이 이상해짐  |                 |

- 트랜잭션A가 원했던 값은 x에 y를 더해 x=60 이어야 했으나 커밋되지 않은 값을 읽으므로써 원하는 값가 다른 이상한 값이 나옴
<br><br>




### 2️⃣ Non-Repeatable Read
- 데이터 x = 10 , y = 50

| 트랜잭션A                | 트랜잭션B           |
|----------------------|-----------------|
| 로직 : x를 두번 조회        | 로직 : x=70 으로 변경 |
| 🚀 시작                |                 |
| 👀 x=10 읽음           | 🚀 시작           |
|                      | ✍️ x=70 으로 변경   |
|            |    ✅ 커밋             |
| 💥 👀 x=70 읽음  |                 |
- 트랜잭션A에서 동일한 읽기 작업을 했는데 값이 달라짐. 하나의 트랜잭션 안에서는 동일한 읽기 행동을 했을때 결과값이 동일해야함. 

<br><br>



### 3️⃣ Phantom Read
- 데이터 x = 10 , y = 50

  | 트랜잭션A                  | 트랜잭션B                |
  |------------------------|----------------------|
  | 로직 : count(x>1)을 두번 조회 | 로직 : x=50, y=50 데이터추가|
  | 🚀 시작                  |                      |
  | 👀 count(x>1)=1  읽음    | 🚀 시작                |
  |                        | ✍️ x=50, y=50 데이터추가        |
  |                        | ✅ 커밋                 |
  | 💥 👀 count(x>1)=2  읽음 |                      |

- 트랜잭션A에서 동일한 읽기 작업을 했는데 다른 컬럼수를 반환.
  <br><br>
---

## 📊 트랜잭션 격리 수준 4단계
| 격리 수준          | Dirty Read 방지 | Non-Repeatable Read 방지 | Phantom Read 방지 |
|------------------|---------------|-------------------------|------------------|
| **READ UNCOMMITTED** | ❌ 방지 안됨 | ❌ 방지 안됨 | ❌ 방지 안됨 |
| **READ COMMITTED**   | ✅ 방지됨   | ❌ 방지 안됨 | ❌ 방지 안됨 |
| **REPEATABLE READ**  | ✅ 방지됨   | ✅ 방지됨   | ❌ 방지 안됨 |
| **SERIALIZABLE**     | ✅ 방지됨   | ✅ 방지됨   | ✅ 방지됨 |

<br><br>

---


## 1️⃣ READ UNCOMMITTED (읽기 미확정)
- Dirty Read, Non-Repeatable Read, Phantom Read 모두 발생 가능
- 트랜잭션이 Commit되지 않아도 다른 트랜잭션에서 읽을 수 있음 → Dirty Read 발생 가능
- 가장 낮은 격리 수준이며 성능이 가장 좋지만, 데이터 정합성이 낮음.

✅ 사용 예시
- 데이터 무결성이 크게 중요하지 않고, 읽기 성능이 최우선인 경우 (ex. 로그 조회)

<br><br>

---


## 2️⃣ READ COMMITTED (읽기 확정)
- Dirty Read 방지 (Commit된 데이터만 읽을 수 있음)
- 하지만 Non-Repeatable Read, Phantom Read 발생 가능
- 한 트랜잭션이 데이터를 읽을 때, 다른 트랜잭션이 Commit을 하면 다음 조회에서 데이터가 바뀔 수 있음.

✅ 사용 예시
- 일반적인 트랜잭션 처리에 적합, 대부분의 DBMS 기본 설정 (ex. Oracle, PostgreSQL 기본 격리 수준)
  <br><br>

---

## 3️⃣ REPEATABLE READ (반복 가능한 읽기)
- Dirty Read, Non-Repeatable Read 방지
- 하지만 Phantom Read 발생 가능
- 한 트랜잭션이 SELECT로 데이터를 조회하면, 그 트랜잭션이 끝날 때까지 다른 트랜잭션이 해당 데이터를 수정할 수 없음.
- 하지만 새로운 데이터가 INSERT되는 것은 방지하지 못함 → Phantom Read 가능성 존재.

✅ 사용 예시
- 트랜잭션 내에서 일관된 데이터를 보장해야 하는 경우 (ex. MySQL의 기본 격리 수준)

<br><br>

---

## 4️⃣ SERIALIZABLE (직렬화)
- Dirty Read, Non-Repeatable Read, Phantom Read 모두 방지
- 가장 높은 격리 수준으로, 모든 트랜잭션을 순차적으로 실행
- 동시에 접근하는 트랜잭션을 차단하기 때문에 성능이 매우 낮아질 수 있음.

✅ 사용 예시
- 가장 높은 수준의 데이터 일관성이 필요한 경우 (ex. 금융 거래, 회계 시스템)

<br><br>

---


