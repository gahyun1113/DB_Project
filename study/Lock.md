# 📌 낙관적 락(Optimistic Lock) & 비관적 락(Pessimistic Lock)


- **동시성 제어(Concurrency Control)를 위해 사용되는 두 가지 대표적인 방법**

<br><br>
  
---

## 1️⃣ 낙관적 락 (Optimistic Lock)
### 동시성 충돌이 적다고 가정하고, 데이터를 업데이트할 때 충돌을 감지하는 방식

### ✅ 원리
- 데이터를 조회할 때 버전 정보(version 필드) 또는 특정 컬럼 값(예: updated_at)을 함께 가져옴.
- 트랜잭션 동안 해당 데이터를 수정하지 않고 유지.
- 데이터를 업데이트할 때, 조회 시 가져온 버전과 현재 버전을 비교.
- 버전이 동일하면 업데이트 수행 후 버전 증가.
- 버전이 다르면 다른 트랜잭션이 데이터를 변경한 것이므로 충돌 발생(예외 처리 필요).
  <br><br>

### ✅ 사용 예시
#### JPA에서 @Version을 활용한 낙관적 락 적용
- JPA는 @Version 필드를 자동으로 관리하며, 업데이트 시 WHERE 절에 버전 정보를 포함하여 변경 충돌을 감지함.
```java
@Entity
public class Product {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String name;
  private int quantity;

  @Version // 버전 필드 추가
  private int version;
}

```
<br><br>
#### SQL 예시 (업데이트 시 버전 체크)
- 만약 version 값이 변경되었다면, 업데이트되지 않음 → 충돌 발생
```sql
UPDATE product
SET quantity = ?, version = version + 1
WHERE id = ? AND version = ?;
```

<br><br>


### ✅ 장점
- 데이터 변경이 적은 경우 효율적.
- 데이터베이스에 락을 걸지 않기 때문에 성능이 좋음.
- 여러 사용자 요청을 병렬로 처리할 수 있음.
  <br><br>

### ✅ 단점
- 동시 수정이 자주 발생하면 충돌로 인해 재시도가 필요함.
- 충돌 발생 시 이를 처리하는 로직이 필요함.
  <br><br>

---

## 2️⃣ 비관적 락 (Pessimistic Lock)
### 데이터 충돌이 자주 발생한다고 가정하고, 데이터를 수정하는 동안 다른 트랜잭션의 접근을 차단하는 방식

### ✅ 원리
- 데이터를 조회할 때 락을 걸어 다른 트랜잭션이 해당 데이터를 수정하지 못하도록 막음.
- 트랜잭션이 끝날 때까지 다른 트랜잭션은 대기해야 함.
- 일반적으로 공유 락(Shared Lock)과 배타 락(Exclusive Lock)을 활용.
  <br><br>
### ✅ 사용 예시
#### JPA에서 PESSIMISTIC_WRITE를 활용한 비관적 락 적용
- PESSIMISTIC_WRITE를 사용하면, 해당 레코드를 다른 트랜잭션이 수정할 수 없도록 배타 락을 걸어버림.
```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT p FROM Product p WHERE p.id = :id")
Product findByIdForUpdate(@Param("id") Long id);
```

<br><br>


#### SQL 예시 (SELECT ... FOR UPDATE)
- FOR UPDATE는 해당 레코드에 배타 락을 걸어 다른 트랜잭션이 접근하지 못하도록 함.
```sql
SELECT * FROM product WHERE id = ? FOR UPDATE;
```
<br><br>


### 📊 공유 락 vs 배타 락
| 비교 항목             | 🔄 공유 락 (Shared Lock)        | 🔒 배타 락 (Exclusive Lock)    |
|-------------------|-------------------------|-------------------------|
| **개념**            | 읽기는 가능하지만 쓰기는 불가능 | 읽기와 쓰기 모두 불가능 |
| **다른 트랜잭션 읽기 허용?** | ✅ 가능                  | ❌ 불가능               |
| **다른 트랜잭션 쓰기 허용?** | ❌ 불가능                | ❌ 불가능               |
| **사용 예**        | 여러 트랜잭션이 동시에 데이터를 조회할 때 | 하나의 트랜잭션이 데이터를 단독 수정할 때 |

<br><br>


### ✅ 장점
- 충돌 발생 가능성이 높은 환경에서 유용함.
- 데이터 정합성이 중요한 경우 안전하게 관리 가능.
  <br><br>

### ✅ 단점
- 락을 걸면 다른 트랜잭션이 대기해야 하므로 성능 저하 가능.
- 데드락(Deadlock) 발생 가능성이 있음.
- 트랜잭션이 길어질 경우 병목이 발생할 수 있음.
  <br><br>

---

## ❓ 언제 어떤 락을 사용해야 할까?
### 낙관적 락
- 다중 트랜잭션이 같은 데이터를 수정할 가능성이 낮을 때.
- 읽기(read) 작업이 많고 쓰기(write) 작업이 적을 때.
- 성능을 중요시하는 경우.
- 예: 쇼핑몰 주문 처리, 게시판 댓글 수정 등.
  <br><br>

### 비관적 락
- 다중 트랜잭션이 같은 데이터를 자주 수정하는 경우.
- 충돌을 방지해야 하는 중요한 데이터(예: 금융, 결제 시스템).
- 데이터 정합성이 최우선일 때.
- 예: 은행 계좌 잔액 수정, 재고 관리 시스템 등.
  <br><br>

---

## 📊 낙관적 락 vs 비관적 락 
| 비교 항목      | 낙관적 락 (Optimistic Lock)                       | 비관적 락 (Pessimistic Lock)                   |
|--------------|---------------------------------|---------------------------------|
| **개념**      | 충돌이 적을 것으로 가정하고 업데이트 시 충돌 감지 | 충돌이 많을 것으로 가정하고 데이터 접근 시 락을 걸어 차단 |
| **구현 방식**  | 버전 번호(`@Version`) 비교 후 업데이트 | `SELECT ... FOR UPDATE`로 락 설정 |
| **동시성 처리** | 충돌 발생 시 재시도 필요 | 트랜잭션이 끝날 때까지 다른 요청 차단 |
| **성능 영향**  | 락을 걸지 않아 성능이 좋음 | 트랜잭션이 길어지면 성능 저하 가능 |
| **사용 예**    | 읽기/쓰기 비율이 높은 환경 | 충돌이 자주 발생하는 환경 |


---

